import java_cup.runtime.*;
import java.util.LinkedList;
import ru.spbau.mit.dbmsau.syntax.ast.*;
import ru.spbau.mit.dbmsau.syntax.exception.SyntaxFatalError;

parser code {: 
    
    LinkedList< String > errors;

    public LinkedList< String > getErrors() {
        return errors;
    }
    
    protected int error_sync_size() {
        return 20;
    }

    public void report_error(String message, Object info) {
        errors.add(message);
    }

    public void report_fatal_error(String message, Object info) throws Exception {
        throw new SyntaxFatalError(message);
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error at: " + cur_token.value.toString(), null);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Couldn't repair and continue parse", null);
    }
    
:};

init with {: 
    errors = new LinkedList<>();
:};

terminal TerminalNode CREATE,TABLE,OR,DIV,MOD,AND,MAIN,LEFTPAR,RIGHTPAR,COMMA,EQUALS,COLON,NOT,NOTEQUAL,LESS,LESSOREQUAL,MORE,MOREOREQUAL,PLUS,MINUS,MULTIPLY,DIVIDE,LEFTBRACKET,RIGHTBRACKET,DOT;
terminal TerminalNode INTEGER_LITERAL;
terminal TerminalNode STRING_LITERAL, IDENT;
terminal TerminalNode DOUBLE_LITERAL;

non terminal ASTNode                      command;
non terminal CreateTableStatementNode     create_table_statement;
non terminal LinkedList< ColumnDescriptionNode > columns_descriptions_list;
non terminal ColumnDescriptionNode        column_description;
non terminal TypeDescriptionNode          type_description;
non terminal TerminalNode                 empty;

precedence left PLUS, MINUS;
precedence left DIV, MULTIPLY, DIVIDE, MOD, AND;
precedence left EQUALS,NOTEQUAL,LESS,LESSOREQUAL,MORE,MOREOREQUAL, OR;

start with command;

command ::= create_table_statement;

create_table_statement ::= CREATE:e1 TABLE:e2 IDENT:tableName LEFTPAR:e3 columns_descriptions_list:fdescList RIGHTPAR:e5
                       {: RESULT = new CreateTableStatementNode(tableName, fdescList); parser.done_parsing(); :}
                       ;

columns_descriptions_list ::= column_description:e1
                             {: RESULT = new LinkedList<>(); RESULT.add(e1); :}
                             |
                             column_description:e1 COMMA:e2 columns_descriptions_list:e3
                             {: RESULT = e3; RESULT.addFirst(e1); :}
                             ;

column_description ::= IDENT:e1 type_description:e2
                      {: RESULT = new ColumnDescriptionNode(e1, e2); :}
                      ;

type_description ::= IDENT:e1
                     {: RESULT = new TypeDescriptionNode(e1); :}
                     |
                     IDENT:e1 LEFTPAR:e2 INTEGER_LITERAL:e3 RIGHTPAR:e4
                     {: RESULT = new TypeDescriptionNode(e1, e3); :}
                     ;

empty ::= ;
